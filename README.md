# Inter-Process Communication (IPC) Project

This project demonstrates **Inter-Process Communication (IPC)** using **Windows Shared Memory** between C++ and Python processes. It includes two implementations:

1. **Simple Visualization** - Basic data sharing between C++ writer and Python reader
2. **YOLOv5 Object Detection** - Real-time video frame and detection data transfer

---

## ğŸ“‹ Table of Contents

- [What is Inter-Process Communication?](#what-is-inter-process-communication)
- [IPC Mechanism Used](#ipc-mechanism-used)
- [Project Structure](#project-structure)
- [Part 1: Simple Visualization](#part-1-simple-visualization)
- [Part 2: YOLOv5 Object Detection](#part-2-yolov5-object-detection)
- [Detailed IPC Flow](#detailed-ipc-flow)
- [Synchronization Mechanisms](#synchronization-mechanisms)
- [Memory Layout](#memory-layout)
- [How to Run](#how-to-run)
- [Troubleshooting](#troubleshooting)

---

## What is Inter-Process Communication?

**Inter-Process Communication (IPC)** is a mechanism that allows different processes (running programs) to exchange data and synchronize their actions. Since each process has its own isolated memory space, special techniques are needed for processes to communicate.

### Common IPC Methods

| Method             | Description                            | Use Case                                        |
| ------------------ | -------------------------------------- | ----------------------------------------------- |
| **Shared Memory**  | Processes share a common memory region | High-speed data transfer (used in this project) |
| **Pipes**          | Unidirectional data channel            | Simple parent-child communication               |
| **Message Queues** | Asynchronous message passing           | Decoupled communication                         |
| **Sockets**        | Network-based communication            | Distributed systems                             |
| **Signals**        | Asynchronous notifications             | Event-driven communication                      |

---

## IPC Mechanism Used

This project uses **Windows Named Shared Memory** as the primary IPC mechanism:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         IPC ARCHITECTURE                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚   PROCESS A     â”‚                        â”‚   PROCESS B     â”‚       â”‚
â”‚   â”‚   (C++ Writer)  â”‚                        â”‚   (Python Reader)â”‚      â”‚
â”‚   â”‚                 â”‚                        â”‚                 â”‚       â”‚
â”‚   â”‚ CreateFileMapping() â”€â”€â”€â”€ Creates â”€â”€â”€â”€â–¶  mmap.mmap()       â”‚       â”‚
â”‚   â”‚ MapViewOfFile()    â”‚                    â”‚  (Connects)      â”‚       â”‚
â”‚   â”‚                 â”‚                        â”‚                 â”‚       â”‚
â”‚   â”‚     WRITE â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€ Shared Memory â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€ READ       â”‚       â”‚
â”‚   â”‚                 â”‚    (Named Region)      â”‚                 â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                         â”‚
â”‚   Key: Both processes access the SAME physical memory region            â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why Shared Memory?

| Advantage          | Description                                                             |
| ------------------ | ----------------------------------------------------------------------- |
| **Speed**          | Direct memory access - no kernel involvement for data transfer          |
| **Zero-Copy**      | Data doesn't need to be copied between processes                        |
| **Large Data**     | Efficient for transferring large amounts of data (images, video frames) |
| **Cross-Language** | Works between any languages that can access memory (C++, Python, etc.)  |

---

## Project Structure

```
IPC/
â”œâ”€â”€ IPC(Simple visualizaton)/           # Basic IPC demonstration
â”‚   â”œâ”€â”€ writer.cpp                      # C++ process that writes data
â”‚   â”œâ”€â”€ reader.py                       # Python process that reads data
â”‚   â”œâ”€â”€ README.md                       # Original documentation
â”‚   â””â”€â”€ QUICKSTART.md                   # Quick start guide
â”‚
â”œâ”€â”€ IPC(yelov5 for object detection)/   # Advanced IPC with YOLO
â”‚   â”œâ”€â”€ producer/                       # C++ Producer
â”‚   â”‚   â”œâ”€â”€ test.cpp                    # YOLO inference + shared memory write
â”‚   â”‚   â”œâ”€â”€ yolov5s.onnx               # YOLO model file
â”‚   â”‚   â”œâ”€â”€ coco-classes.txt           # Object class names
â”‚   â”‚   â””â”€â”€ *.vcxproj                  # Visual Studio project files
â”‚   â”‚
â”‚   â””â”€â”€ consumer/                       # Python Consumer
â”‚       â”œâ”€â”€ consumer_shm.py            # Shared memory reader + visualization
â”‚       â”œâ”€â”€ coco-classes.txt           # Object class names
â”‚       â””â”€â”€ requirements.txt           # Python dependencies
â”‚
â””â”€â”€ README.md                           # This file
```

---

## ğŸ“¸ Output Examples

Below are screenshots demonstrating the IPC system in action:

### YOLOv5 Object Detection with IPC

<img src="image(output)/WhatsApp%20Image%202026-02-03%20at%208.20.57%20AM%20(1).jpeg" width="600" alt="Object Detection Output 1">

<img src="image(output)/WhatsApp%20Image%202026-02-03%20at%208.20.57%20AM.jpeg" width="600" alt="Object Detection Output 2">

<img src="image(output)/WhatsApp%20Image%202026-02-03%20at%208.20.58%20AM%20(1).jpeg" width="600" alt="Object Detection Output 3">

<img src="image(output)/WhatsApp%20Image%202026-02-03%20at%208.20.58%20AM%20(2).jpeg" width="600" alt="Object Detection Output 4">

<img src="image(output)/WhatsApp%20Image%202026-02-03%20at%208.20.58%20AM%20(3).jpeg" width="600" alt="Object Detection Output 5">

<img src="image(output)/WhatsApp%20Image%202026-02-03%20at%208.20.58%20AM%20(4).jpeg" width="600" alt="Object Detection Output 6">

<img src="image(output)/WhatsApp%20Image%202026-02-03%20at%208.20.58%20AM.jpeg" width="600" alt="Object Detection Output 7">

---

## Part 1: Simple Visualization

### Overview

A basic demonstration where:

- **C++ Writer** creates shared memory and writes structured data
- **Python Reader** connects to shared memory and reads the data

### Data Structure

```cpp
// C++ Structure (writer.cpp)
struct SharedData {
    int processId;           // 4 bytes
    char message[500];       // 500 bytes
    bool dataReady;          // 1 byte + 3 padding
    int counter;             // 4 bytes
    double temperature;      // 8 bytes
    float coordinates[3];    // 12 bytes
    char userName[50];       // 50 bytes + 6 padding
    long long timestamp;     // 8 bytes
    int dataArray[10];       // 40 bytes
};
```

### How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SIMPLE IPC DATA FLOW                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   C++ WRITER (writer.cpp)                                              â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                              â”‚
â”‚                                                                         â”‚
â”‚   1. CreateFileMappingA("Local\\IPCSharedMemory", 1024)                â”‚
â”‚      â””â”€â”€ Creates a named shared memory segment of 1024 bytes           â”‚
â”‚                                                                         â”‚
â”‚   2. MapViewOfFile()                                                   â”‚
â”‚      â””â”€â”€ Maps the shared memory into the process's address space       â”‚
â”‚                                                                         â”‚
â”‚   3. Write data to SharedData structure                                 â”‚
â”‚      â€¢ processId = GetCurrentProcessId()                               â”‚
â”‚      â€¢ message = "Hello from C++ Process!"                             â”‚
â”‚      â€¢ counter = 42                                                     â”‚
â”‚      â€¢ temperature = 23.5                                              â”‚
â”‚      â€¢ dataReady = true                                                â”‚
â”‚                                                                         â”‚
â”‚   4. Wait for user input (keeps memory alive)                          â”‚
â”‚                                                                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚                                                                         â”‚
â”‚   PYTHON READER (reader.py)                                            â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                            â”‚
â”‚                                                                         â”‚
â”‚   1. mmap.mmap(-1, 1024, "Local\\IPCSharedMemory")                     â”‚
â”‚      â””â”€â”€ Opens existing shared memory by name                          â”‚
â”‚                                                                         â”‚
â”‚   2. shm.read(1024)                                                    â”‚
â”‚      â””â”€â”€ Reads raw bytes from shared memory                            â”‚
â”‚                                                                         â”‚
â”‚   3. struct.unpack()                                                   â”‚
â”‚      â””â”€â”€ Converts raw bytes to Python data types                       â”‚
â”‚      â””â”€â”€ Must match C++ structure layout exactly!                      â”‚
â”‚                                                                         â”‚
â”‚   4. Display data to user                                              â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Code Snippets

**C++ Writer - Creating Shared Memory:**

```cpp
// Create shared memory segment
HANDLE hMapFile = CreateFileMappingA(
    INVALID_HANDLE_VALUE,    // Use system paging file
    NULL,                    // Default security
    PAGE_READWRITE,          // Read/write access
    0, SHM_SIZE,             // Size (1024 bytes)
    "Local\\IPCSharedMemory" // Name for identification
);

// Map to process address space
SharedData* sharedData = (SharedData*)MapViewOfFile(
    hMapFile,
    FILE_MAP_ALL_ACCESS,
    0, 0, SHM_SIZE
);

// Write data
sharedData->counter = 42;
sharedData->dataReady = true;
```

**Python Reader - Connecting and Reading:**

```python
# Connect to existing shared memory
shm = mmap.mmap(-1, SHM_SIZE, "Local\\IPCSharedMemory")

# Read raw bytes
raw_data = shm.read(SHM_SIZE)

# Unpack using struct (must match C++ layout)
process_id = struct.unpack('i', raw_data[0:4])[0]
counter = struct.unpack('i', raw_data[508:512])[0]
```

---

## Part 2: YOLOv5 Object Detection

### Overview

An advanced implementation featuring:

- **C++ Producer**: Captures video frames, runs YOLOv5 inference, writes results to shared memory
- **Python Consumer**: Reads frames and detections, draws bounding boxes, displays results

### System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    YOLO IPC SYSTEM ARCHITECTURE                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚   PRODUCER      â”‚                        â”‚   CONSUMER      â”‚       â”‚
â”‚   â”‚   (C++)         â”‚                        â”‚   (Python)      â”‚       â”‚
â”‚   â”‚                 â”‚                        â”‚                 â”‚       â”‚
â”‚   â”‚ â€¢ Video Input   â”‚                        â”‚ â€¢ Read Frames   â”‚       â”‚
â”‚   â”‚ â€¢ YOLO Inferenceâ”‚â”€â”€â”€â”€ Shared Memory â”€â”€â”€â”€â–¶â”‚ â€¢ Draw Boxes    â”‚       â”‚
â”‚   â”‚ â€¢ Detection     â”‚   (Circular Queue)     â”‚ â€¢ Display       â”‚       â”‚
â”‚   â”‚ â€¢ Write Frames  â”‚                        â”‚                 â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                         â”‚
â”‚                    Synchronization via:                                 â”‚
â”‚                    â€¢ Semaphores (Empty/Full)                            â”‚
â”‚                    â€¢ Mutex (Mutual Exclusion)                           â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Shared Memory Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SHARED MEMORY STRUCTURE                         â”‚
â”‚                         Total Size: ~5.88 MB                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ CONTROL BLOCK (12 bytes)                                          â”‚ â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚ â”‚
â”‚  â”‚ â”‚ write_idx   â”‚ read_idx    â”‚ count       â”‚                       â”‚ â”‚
â”‚  â”‚ â”‚ (4 bytes)   â”‚ (4 bytes)   â”‚ (4 bytes)   â”‚                       â”‚ â”‚
â”‚  â”‚ â”‚ Next write  â”‚ Next read   â”‚ Items in    â”‚                       â”‚ â”‚
â”‚  â”‚ â”‚ position    â”‚ position    â”‚ queue       â”‚                       â”‚ â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ CIRCULAR QUEUE (5 Slots Ã— 1,233,620 bytes each)                   â”‚ â”‚
â”‚  â”‚                                                                    â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚ â”‚
â”‚  â”‚  â”‚ Slot 0  â”‚ Slot 1  â”‚ Slot 2  â”‚ Slot 3  â”‚ Slot 4  â”‚             â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ â”‚
â”‚  â”‚                                                                    â”‚ â”‚
â”‚  â”‚  Each Slot Structure:                                             â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚ â”‚
â”‚  â”‚  â”‚ HEADER (20 bytes)                                â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ frame_id (4 bytes) - Frame sequence number     â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ width (4 bytes) - Always 640                   â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ height (4 bytes) - Always 640                  â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ channels (4 bytes) - Always 3 (BGR)            â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ num_detections (4 bytes) - Count of objects    â”‚            â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚ â”‚
â”‚  â”‚  â”‚ DETECTIONS (200 Ã— 24 bytes = 4,800 bytes)        â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ Each detection (24 bytes):                       â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ class_id (4 bytes, int) - COCO class index     â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ confidence (4 bytes, float) - Detection score  â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ x (4 bytes, int) - Bounding box left           â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ y (4 bytes, int) - Bounding box top            â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ width (4 bytes, int) - Box width               â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ height (4 bytes, int) - Box height             â”‚            â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚ â”‚
â”‚  â”‚  â”‚ IMAGE DATA (640 Ã— 640 Ã— 3 = 1,228,800 bytes)     â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ BGR format, uint8 pixels                       â”‚            â”‚ â”‚
â”‚  â”‚  â”‚ â€¢ Row-major order                                â”‚            â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚ â”‚
â”‚  â”‚                                                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Detailed IPC Flow

### Producer Write Operation (C++)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      PRODUCER WRITE FLOW                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  1. WAIT FOR EMPTY SLOT                                                â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ WaitForSingleObject(semEmpty, INFINITE)                        â”‚ â”‚
â”‚     â”‚ â€¢ Blocks if all 5 slots are full (semEmpty == 0)              â”‚ â”‚
â”‚     â”‚ â€¢ Decrements semEmpty counter when proceeds                    â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  2. ACQUIRE MUTEX (EXCLUSIVE ACCESS)                                   â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ WaitForSingleObject(mutex, INFINITE)                           â”‚ â”‚
â”‚     â”‚ â€¢ Ensures only one process accesses memory at a time          â”‚ â”‚
â”‚     â”‚ â€¢ Prevents data corruption from simultaneous read/write       â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  3. CALCULATE SLOT ADDRESS                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ int write_idx = ctrl[0];  // Read current write position       â”‚ â”‚
â”‚     â”‚ uint8_t* slot = shm + 12 + (write_idx * SLOT_SIZE);           â”‚ â”‚
â”‚     â”‚ â€¢ Circular: position wraps from 4 back to 0                    â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  4. WRITE DATA TO SLOT                                                 â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ â€¢ Write header (frame_id, dimensions, detection count)         â”‚ â”‚
â”‚     â”‚ â€¢ Write detection records (class_id, confidence, bbox)         â”‚ â”‚
â”‚     â”‚ â€¢ Write image data (640Ã—640Ã—3 BGR pixels)                     â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  5. UPDATE CONTROL BLOCK                                               â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ ctrl[0] = (write_idx + 1) % QUEUE_SIZE;  // Advance pointer    â”‚ â”‚
â”‚     â”‚ ctrl[2]++;  // Increment item count                            â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  6. RELEASE MUTEX                                                      â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ ReleaseMutex(mutex);                                           â”‚ â”‚
â”‚     â”‚ â€¢ Allows other process to access shared memory                 â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  7. SIGNAL DATA AVAILABLE                                              â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ ReleaseSemaphore(semFull, 1, nullptr);                         â”‚ â”‚
â”‚     â”‚ â€¢ Increments semFull counter                                   â”‚ â”‚
â”‚     â”‚ â€¢ Wakes up consumer if it was waiting                          â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Consumer Read Operation (Python)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      CONSUMER READ FLOW                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  1. WAIT FOR DATA                                                      â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ WaitForSingleObject(semFull, INFINITE)                         â”‚ â”‚
â”‚     â”‚ â€¢ Blocks if no data available (semFull == 0)                   â”‚ â”‚
â”‚     â”‚ â€¢ Decrements semFull counter when proceeds                     â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  2. ACQUIRE MUTEX                                                      â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ WaitForSingleObject(mutex, INFINITE)                           â”‚ â”‚
â”‚     â”‚ â€¢ Ensures exclusive access during read                         â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  3. READ CONTROL BLOCK                                                 â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ write_idx, read_idx, count = struct.unpack("iii", shm.read(12))â”‚ â”‚
â”‚     â”‚ slot_start = 12 + (read_idx * SLOT_SIZE)                       â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  4. READ SLOT DATA                                                     â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ â€¢ Read header â†’ frame_id, dimensions, num_detections           â”‚ â”‚
â”‚     â”‚ â€¢ Read detections â†’ class_id, confidence, x, y, w, h           â”‚ â”‚
â”‚     â”‚ â€¢ Read image â†’ numpy array of shape (640, 640, 3)              â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  5. UPDATE CONTROL BLOCK                                               â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ new_read_idx = (read_idx + 1) % QUEUE_SIZE                     â”‚ â”‚
â”‚     â”‚ shm.write(struct.pack("i", new_read_idx))  // Update read_idx  â”‚ â”‚
â”‚     â”‚ shm.write(struct.pack("i", count - 1))     // Decrement count  â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  6. RELEASE MUTEX                                                      â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ ReleaseMutex(mutex)                                            â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â–¼                                          â”‚
â”‚  7. SIGNAL SLOT FREE                                                   â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚     â”‚ ReleaseSemaphore(semEmpty, 1)                                  â”‚ â”‚
â”‚     â”‚ â€¢ Increments semEmpty counter                                  â”‚ â”‚
â”‚     â”‚ â€¢ Wakes up producer if it was waiting for empty slot           â”‚ â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Synchronization Mechanisms

### Why Synchronization is Needed

Without proper synchronization:

- **Race Condition**: Producer and consumer might access data simultaneously
- **Buffer Overflow**: Producer might overwrite unread data
- **Buffer Underflow**: Consumer might read garbage data

### Synchronization Primitives Used

| Primitive           | Name               | Initial Value | Purpose                                     |
| ------------------- | ------------------ | ------------- | ------------------------------------------- |
| **Semaphore Empty** | `Local\YOLO_EMPTY` | 5             | Counts available (empty) slots for producer |
| **Semaphore Full**  | `Local\YOLO_FULL`  | 0             | Counts filled slots ready for consumer      |
| **Mutex**           | `Local\YOLO_MUTEX` | Unlocked      | Ensures exclusive access during read/write  |

### Semaphore Operation Timeline

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SYNCHRONIZATION TIMELINE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  Initial State:  semEmpty = 5,  semFull = 0                            â”‚
â”‚                                                                         â”‚
â”‚  PRODUCER                           CONSUMER                            â”‚
â”‚  â•â•â•â•â•â•â•â•                           â•â•â•â•â•â•â•â•                            â”‚
â”‚                                                                         â”‚
â”‚  Wait(semEmpty)                                                        â”‚
â”‚  semEmpty: 5 â†’ 4 âœ“                                                     â”‚
â”‚                                                                         â”‚
â”‚  [WRITE Frame 1]                    Wait(semFull)                      â”‚
â”‚                                     semFull: 0 â†’ BLOCKED               â”‚
â”‚                                                                         â”‚
â”‚  Signal(semFull)                                                       â”‚
â”‚  semFull: 0 â†’ 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ semFull: 1 â†’ 0 âœ“                  â”‚
â”‚                                                                         â”‚
â”‚  Wait(semEmpty)                     [READ Frame 1]                     â”‚
â”‚  semEmpty: 4 â†’ 3 âœ“                                                     â”‚
â”‚                                                                         â”‚
â”‚  [WRITE Frame 2]                    Signal(semEmpty)                   â”‚
â”‚                                     semEmpty: 3 â†’ 4                     â”‚
â”‚                                                                         â”‚
â”‚  ... (continues)                    ... (continues)                     â”‚
â”‚                                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚                                                                         â”‚
â”‚  When Queue is FULL (semEmpty = 0):                                    â”‚
â”‚  â€¢ Producer blocks on Wait(semEmpty)                                   â”‚
â”‚  â€¢ Producer waits until consumer reads and signals semEmpty            â”‚
â”‚                                                                         â”‚
â”‚  When Queue is EMPTY (semFull = 0):                                    â”‚
â”‚  â€¢ Consumer blocks on Wait(semFull)                                    â”‚
â”‚  â€¢ Consumer waits until producer writes and signals semFull            â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Circular Buffer Visualization

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CIRCULAR BUFFER OPERATION                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  Initial State:                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”                                                 â”‚
â”‚  â”‚   â”‚   â”‚   â”‚   â”‚   â”‚  write_idx = 0, read_idx = 0, count = 0         â”‚
â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                                                 â”‚
â”‚   W/R                    (Both pointers at position 0)                  â”‚
â”‚                                                                         â”‚
â”‚  After Producer writes 3 frames:                                        â”‚
â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”                                                 â”‚
â”‚  â”‚ F1â”‚ F2â”‚ F3â”‚   â”‚   â”‚  write_idx = 3, read_idx = 0, count = 3         â”‚
â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                                                 â”‚
â”‚    R          W          (R = Read position, W = Write position)        â”‚
â”‚                                                                         â”‚
â”‚  After Consumer reads 2 frames:                                         â”‚
â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”                                                 â”‚
â”‚  â”‚   â”‚   â”‚ F3â”‚   â”‚   â”‚  write_idx = 3, read_idx = 2, count = 1         â”‚
â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                                                 â”‚
â”‚            R   W                                                        â”‚
â”‚                                                                         â”‚
â”‚  Wraparound (after many operations):                                    â”‚
â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”                                                 â”‚
â”‚  â”‚F10â”‚   â”‚   â”‚ F8â”‚ F9â”‚  write_idx = 1, read_idx = 3, count = 3         â”‚
â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                                                 â”‚
â”‚       W       R          (Write pointer wrapped around)                 â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Memory Layout

### Structure Alignment (Important!)

When sharing memory between C++ and Python, **byte alignment** must match exactly:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    C++ STRUCTURE MEMORY LAYOUT                          â”‚
â”‚                    (Simple Visualization Example)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  Offset   Size    Field              Notes                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€   â”€â”€â”€â”€    â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€                             â”‚
â”‚  0        4       processId          int (4 bytes)                      â”‚
â”‚  4        500     message[500]       char array                         â”‚
â”‚  504      1       dataReady          bool                               â”‚
â”‚  505      3       (padding)          Alignment to 4-byte boundary       â”‚
â”‚  508      4       counter            int                                â”‚
â”‚  512      8       temperature        double (8-byte aligned)            â”‚
â”‚  520      12      coordinates[3]     3 floats                           â”‚
â”‚  532      50      userName[50]       char array                         â”‚
â”‚  582      6       (padding)          Alignment to 8-byte boundary       â”‚
â”‚  588      8       timestamp          long long (8-byte aligned)         â”‚
â”‚  596      40      dataArray[10]      10 ints                            â”‚
â”‚  636      -       Total Size                                            â”‚
â”‚                                                                         â”‚
â”‚  Python must read at EXACT same offsets using struct.unpack()          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Python struct Format Strings

```python
# Common format characters:
# 'i' = int (4 bytes)
# 'f' = float (4 bytes)
# 'd' = double (8 bytes)
# 'Q' = unsigned long long (8 bytes)
# '500s' = 500-byte string

# Example: Read process_id (int at offset 0)
process_id = struct.unpack('i', data[0:4])[0]

# Example: Read temperature (double at offset 512)
temperature = struct.unpack('d', data[512:520])[0]

# Example: Read 3 float coordinates
coordinates = struct.unpack('fff', data[520:532])
```

---

## How to Run

### Simple Visualization

**Step 1: Compile C++ Writer**

```bash
cd "IPC(Simple visualizaton)"
g++ writer.cpp -o writer.exe
```

**Step 2: Run C++ Writer (Terminal 1)**

```bash
./writer.exe
```

**Step 3: Run Python Reader (Terminal 2)**

```bash
python reader.py
```

### YOLOv5 Object Detection

**Prerequisites:**

- Visual Studio 2019/2022 with C++ desktop development
- OpenCV 4.x
- ONNX Runtime
- Python 3.8+ with packages: `opencv-python`, `numpy`, `pywin32`

**Step 1: Build C++ Producer**

```bash
cd "IPC(yelov5 for object detection)/producer"
# Open assignment_cpp.sln in Visual Studio
# Build in Release or Debug mode
```

**Step 2: Run C++ Producer (Creates shared memory)**

```bash
./assignment_cpp.exe
```

**Step 3: Install Python Dependencies**

```bash
cd "../consumer"
pip install -r requirements.txt
```

**Step 4: Run Python Consumer**

```bash
python consumer_shm.py
```

**Controls:**

- `ESC` - Exit application
- `SPACE` - Pause/Resume

---

## Troubleshooting

| Issue                      | Cause                            | Solution                              |
| -------------------------- | -------------------------------- | ------------------------------------- |
| "Shared memory not found"  | Consumer started before producer | Start producer first                  |
| "Access denied"            | Permission issues                | Run as Administrator                  |
| Data appears corrupted     | Structure alignment mismatch     | Verify byte offsets match             |
| Consumer receives old data | Circular buffer full             | Increase QUEUE_SIZE                   |
| No detections displayed    | Model file missing               | Ensure `yolov5s.onnx` exists          |
| Video not found            | Missing video file               | Place `video.mp4` in producer folder  |
| Python import errors       | Missing packages                 | Run `pip install -r requirements.txt` |

---

## Key Concepts Summary

| Concept               | Description                                                                          |
| --------------------- | ------------------------------------------------------------------------------------ |
| **Shared Memory**     | Memory region accessible by multiple processes                                       |
| **Named Mapping**     | Uses a string name (e.g., `Local\\IPCSharedMemory`) so processes can find each other |
| **Semaphore**         | Counter that blocks threads when it reaches zero - used for signaling                |
| **Mutex**             | Mutual exclusion lock - ensures only one process accesses critical section           |
| **Circular Buffer**   | Fixed-size queue that wraps around - efficient for streaming data                    |
| **Producer-Consumer** | Design pattern where one process generates data, another processes it                |
| **Memory Alignment**  | Data types must start at specific byte boundaries for proper access                  |

---

## References

- [Windows Shared Memory (MSDN)](https://docs.microsoft.com/en-us/windows/win32/memory/creating-named-shared-memory)
- [Windows Semaphores (MSDN)](https://docs.microsoft.com/en-us/windows/win32/sync/using-semaphore-objects)
- [Python mmap Module](https://docs.python.org/3/library/mmap.html)
- [Python struct Module](https://docs.python.org/3/library/struct.html)
- [YOLOv5 Documentation](https://github.com/ultralytics/yolov5)
- [ONNX Runtime](https://onnxruntime.ai/)
